"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createErisClient = exports.createDjsClient = exports.DBLClient = void 0;
const node_timers_1 = require("node:timers");
const tiny_typed_emitter_1 = require("tiny-typed-emitter");
const api_1 = require("../api");
const internal_1 = require("../internal");
const webhooks_1 = require("../webhooks");
const adapters_1 = require("./adapters");
const WEBHOOKS_SUGGESTION = "[discordbotlist] More than 500 users have voted for your bot in the past 12 hours. You may want to consider switching to webhooks to provide a more seamless experience for your users. Learn more at https://docs.discordbotlist.com/vote-webhooks";
class DBLClient extends tiny_typed_emitter_1.TypedEmitter {
    constructor(apiKey, adapter) {
        super();
        this.apiKey = apiKey;
        this.adapter = adapter;
        this._useWebhooksSuggestionSent = false;
        this._lastVote = new Date();
        this._post = null;
        this._voteCheck = null;
    }
    /** Get the bot's recent votes (within the past 12 hours). */
    async fetchRecentVotes() {
        try {
            return await (0, api_1.fetchRecentVotes)(this.apiKey, this.adapter.botId);
        }
        catch (e) {
            const error = new internal_1.DBLError("Failed to fetch recent votes", {
                client: this,
                error: e,
            });
            this.emit("error", error, this);
            throw error;
        }
    }
    /** Post the slash commands your bot supports. These will be shown on your bot page. */
    async postBotCommands(commands) {
        try {
            await (0, api_1.postBotCommands)(this.apiKey, this.adapter.botId, commands);
        }
        catch (e) {
            const error = new internal_1.DBLError("Failed to post bot commands", {
                client: this,
                error: e,
            });
            this.emit("error", error, this);
            throw error;
        }
    }
    /** Post bot stats to be displayed on the website. */
    async postBotStats(stats) {
        try {
            stats ?? (stats = await this.adapter.getBotStats());
            await (0, api_1.postBotStats)(this.apiKey, this.adapter.botId, stats);
            this.emit("posted", stats, this);
        }
        catch (e) {
            const error = new internal_1.DBLError("Failed to post bot stats", {
                client: this,
                error: e,
            });
            this.emit("error", error, this);
            throw error;
        }
    }
    /** Stops this client from posting stats to DBL. */
    stopPosting() {
        if (this._post) {
            (0, node_timers_1.clearInterval)(this._post);
            this._post = null;
        }
    }
    /**
     * Starts posting stats to DBL with the specified interval.
     * @param interval Frequency with which to post bot stats. Defaults to every hour.
     */
    startPosting(interval = 3600000) {
        this.stopPosting();
        this.postBotStats().catch(() => null);
        this._post = (0, node_timers_1.setInterval)(() => this.postBotStats().catch(() => null), interval).unref();
    }
    /** Stops this client from polling for recent votes from DBL. */
    stopPolling() {
        if (this._voteCheck) {
            (0, node_timers_1.clearInterval)(this._voteCheck);
            this._voteCheck = null;
        }
    }
    async _checkVotes() {
        const recent = await this.fetchRecentVotes().catch(() => null);
        if (!recent)
            return;
        if (!this._useWebhooksSuggestionSent && recent.votes.length >= 500) {
            console.warn(WEBHOOKS_SUGGESTION);
            this._useWebhooksSuggestionSent = true;
        }
        recent.votes.filter(vote => vote.time > this._lastVote).forEach(vote => this.emit("vote", vote, this));
        this._lastVote = new Date();
    }
    /**
     * Starts polling for recent votes from DBL with the specified interval.
     * @param interval Frequency with which to post bot stats. Defaults to every 5 minutes.
     */
    startPolling(interval = 300000) {
        this.stopPolling();
        this._checkVotes().catch(() => null);
        this._voteCheck = (0, node_timers_1.setInterval)(() => this._checkVotes().catch(() => null), interval);
    }
    webhook(secret) {
        return (0, webhooks_1.upvoteListener)(secret, vote => this.emit("vote", vote, this));
    }
}
exports.DBLClient = DBLClient;
function createDjsClient(apiKey, client) {
    return new DBLClient(apiKey, new adapters_1.DjsAdapter(client));
}
exports.createDjsClient = createDjsClient;
function createErisClient(apiKey, client) {
    return new DBLClient(apiKey, new adapters_1.ErisAdapter(client));
}
exports.createErisClient = createErisClient;
